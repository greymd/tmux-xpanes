#!/bin/bash

# @Author Yamada, Yasuhiro
# @Filename xpanes

set -u
readonly XP_VERSION="2.2.1"

## --------------------------------
# Error constants
## --------------------------------
# Undefined or General errors
readonly XP_EUNDEF=1

# Invalid option/argument
readonly XP_EINVAL=4

# Could not open tty.
readonly XP_ETTY=5

# Invalid layout.
readonly XP_ELAYOUT=6

# Log related exit status is 2x.
## Could not create a directory.
readonly XP_ELOGDIR=20

## Could not directory to store logs is not writable.
readonly XP_ELOGWRITE=21

# Necessary commands are not found
readonly XP_ENOCMD=127

# ===============

# Used tmux command by default.
# i.e, the command can be another one like 'export TMUX_XPANES_EXEC="tmux -2"'
TMUX_XPANES_EXEC=${TMUX_XPANES_EXEC:-tmux}

# XP_THIS_FILE_NAME is supposed to be "xpanes".
readonly XP_THIS_FILE_NAME="${0##*/}"
readonly XP_THIS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]:-${(%):-%N}}")" && pwd)"
readonly XP_ABS_THIS_FILE_NAME="$XP_THIS_DIR/$XP_THIS_FILE_NAME"

# Prevent cache directory being created under root / directory in any case.
# This is quite rare case (but it can be happened).
readonly XP_USER_HOME="${HOME:-/etc}"

# Basically xpanes follows XDG Base Direcotry Specification.
# https://specifications.freedesktop.org/basedir-spec/basedir-spec-0.6.html
XDG_CACHE_HOME="${XDG_CACHE_HOME:-$XP_USER_HOME/.cache}"
readonly XP_CACHE_HOME="${XDG_CACHE_HOME}/xpanes"

# This is supposed to be xpanes-12345(PID)
readonly XP_SESSION_NAME="$XP_THIS_FILE_NAME-$$"
# Temporary window name is tmp-12345(PID)
readonly XP_TMP_WIN_NAME="tmp-$$"
readonly XP_EMPTY_STR="EMPTY"

readonly XP_SUPPORT_TMUX_VERSION_LOWER="1.6"
readonly XP_DEPENDENCIES="${XP_DEPENDENCIES:-tmux perl}"

## --------------------------------
# Initialize Options
## --------------------------------
# options which work individually.
readonly XP_FLAG_OPTIONS="[hVde]"
# options which need arguments.
readonly XP_ARG_OPTIONS="[IScln]"
readonly XP_DEFAULT_LAYOUT="tiled"
readonly XP_DEFAULT_REPSTR="{}"
readonly XP_DEFAULT_CMD_UTILITY="echo {} "
readonly XP_SSH_CMD_UTILITY="ssh -o StrictHostKeyChecking=no {} "
XP_OPTIONS=()
XP_ARGS=()
XP_STDIN=()
XP_IS_PIPE_MODE=0
XP_OPT_IS_SYNC=1
XP_OPT_DRY_RUN=0
XP_OPT_ATTACH=1
XP_OPT_LOG_STORE=0
XP_LOG_DIR="${XP_LOG_DIR:-$XP_CACHE_HOME/logs}"
XP_LOG_FORMAT="[:ARG:].log.%Y-%m-%d_%H-%M-%S"
XP_REPSTR=""
XP_SOCKET_PATH="${XP_SOCKET_PATH:-$XP_CACHE_HOME/socket}"
XP_NO_OPT=0
XP_OPT_CMD_UTILITY=0
XP_CMD_UTILITY=""
XP_LAYOUT="$XP_DEFAULT_LAYOUT"
XP_MAX_PANE_ARGS=""

## --------------------------------
# Logger
#   $1 -- Log level (i.e Warning, Error)
#   $2 -- Message
#   i.e
#      xpanes:Error: invalid option.
#
# This log format is created with reference to openssl's one.
#   $ echo | openssl -a
#   openssl:Error: '-a' is an invalid command.
## --------------------------------
xpns_msg() {
  local _loglevel="$1"
  local _msgbody="$2"
  local _msg="$XP_THIS_FILE_NAME:$_loglevel: ${_msgbody}"
  echo "${_msg}" >&2
}

xpns_usage() {
  cat << _EOS_
Usage:
  $XP_THIS_FILE_NAME [OPTIONS] [argument ...]

Usage(pipe mode):
  command ... | $XP_THIS_FILE_NAME [OPTIONS] [<utility> ...]

OPTIONS:
  -h,--help                    Show this screen.
  -V,--version                 Show version.
  -c <utility>                 Specify <utility> which is executed as a command in each panes. If <utility> is omitted, echo(1) is used.
  -d,--desync                  Make synchronize-panes option off on new window.
  -e                           Execute given arguments as is.
  -I <repstr>                  Replacing one or more occurrences of <repstr> in <utility> given by -c option. Default value of <repstr> is {}.
  -l <layout>                  Specify a layout for a window. Recognized layout arguments are:
                               t    tiled (default)
                               eh   even-horizontal
                               ev   even-vertical
                               mh   main-horizontal
                               mv   main-vertical
  -n <number>                  Set the maximum number of arguments taken for each pane of <utility>.
  -S <socket-path>             Specify a full alternative path to the server socket.
  --log[=<directory>]          Enable logging and store log files to ~/.cache/xpanes/logs or given <directory>.
  --log-format=<FORMAT>        File name of log files follows given <FORMAT>.
  --ssh                        Let <utility> 'ssh -o StrictHostKeyChecking=no {}'.
  --stay                       Do not switch to new window.

_EOS_
}

xpns_usage_verbose() {
  cat << _EOS_
FORMAT:
    Default value is "$XP_LOG_FORMAT"
    Interpreted sequences are:
    [:PID:]   Process id of the tmux session. (e.g, 41531)
    [:ARG:]   Argument name

    In addition, sequences same as date(1) command are available.

    For example:
    %Y   year  (e.g, 1960)
    %m   month (e.g, 01)
    %d   date  (e.g, 31)
    And etc.
    Other sequences are available. Please refer to date(1) manual.

Copyright (c) 2017 Yamada, Yasuhiro
Released under the MIT License.
https://github.com/greymd/tmux-xpanes
_EOS_
}

# Show version number
xpns_version() {
  echo "$XP_THIS_FILE_NAME $XP_VERSION"
}

# Get version number for tmux
xpns_get_tmux_version() {
  local _tmux_version=""
  if ! $TMUX_XPANES_EXEC -V &> /dev/null; then
    # From tmux 0.9 to 1.3, there is no -V option.
    _tmux_version="tmux 0.9-1.3"
  else
    _tmux_version="$($TMUX_XPANES_EXEC -V)"
  fi
  echo "$_tmux_version" | perl -anle 'printf "%s", "$F[1]"'
}

# Check whether the given version is greater than current tmux version.
# $1 ... Target version.
# $2 ... Current tmux version.
# In case of tmux version is 1.7, the result will be like this.
# 0 is true, 1 is false.
##  arg  -> result
#   func 1.5  1.7 -> 0
#   func 1.6  1.7 -> 0
#   func 1.7  1.7 -> 0
#   func 1.8  1.7 -> 1
#   func 1.9  1.7 -> 1
#   func 1.9a 1.7 -> 1
#   func 2.0  1.7 -> 1
xpns_tmux_is_greater_equals() {
  local _check_version="$1"
  local _tmux_version="${2:-$(xpns_get_tmux_version)}"
  # Simple numerical comparison does not work because there is the version like "1.9a".
  if [[ "$( (echo "$_tmux_version"; echo "$_check_version") | sort -n | head -n 1)" != "$_check_version" ]];then
    return 1
  else
    return 0
  fi
}

xpns_get_tmux_conf() {
  local _conf_name="$1"
  local _session="${2-}"
  {
    if [ -z "${_session-}" ];then
      $TMUX_XPANES_EXEC show-window-options -g
    else
      $TMUX_XPANES_EXEC -S "$_session" show-window-options -g
    fi
  } | grep "^${_conf_name}" \
    | head -n 1 \
    | perl -anle 'print $F[1]'
}

# Disable allow-rename because
# window separation does not work correctly
# if "allow-rename" option is on
xpns_suppress_allow_rename () {
  local _default_allow_rename="$1"
  local _session="${2-}"
  if [[ "${_default_allow_rename-}" == "on"  ]]; then
    ## Temporary, disable "allow-rename"
    # xpns_msg "Info" "'allow-rename' option is 'off' temporarily."
    if [ -z "${_session-}" ];then
      $TMUX_XPANES_EXEC set-window-option -g allow-rename off
    else
      $TMUX_XPANES_EXEC -S "$_session" set-window-option -g allow-rename off
    fi
  fi
}

# Restore default "allow-rename"
# Do not write like 'xpns_restore_allow_rename "some value" "some value" > /dev/null'
# In tmux 1.6, 'tmux set-window-option' might be stopped in case of redirection.
xpns_restore_allow_rename () {
  local _default_allow_rename="$1"
  local _session="${2-}"
  if [[ "${_default_allow_rename-}" == "on"  ]]; then
    # xpns_msg "Info" "Restore original value of 'allow-rename' option."
    if [ -z "${_session-}" ];then
      $TMUX_XPANES_EXEC set-window-option -g allow-rename on
    else
      $TMUX_XPANES_EXEC -S "$_session" set-window-option -g allow-rename on
    fi
  fi
}

#
# Generate log file names from given arguments.
# Usage:
#        echo <arg1> <arg2> ... | xpns_log_filenames <FORMAT>
# Return:
#        File names.
# Example:
#        $ echo aaa bbb ccc aaa ccc ccc | xargs -n 1 | xpns_log_filenames '[:ARG:]_[:PID:]_%Y%m%d.log'
#        aaa-1_1234_20160101.log
#        bbb-1_1234_20160101.log
#        ccc-1_1234_20160101.log
#        aaa-2_1234_20160101.log
#        ccc-2_1234_20160101.log
#        ccc-3_1234_20160101.log
#
xpns_log_filenames () {
  local _arg_fmt="$1"
  local _full_fmt=
  _full_fmt="$(date "+${_arg_fmt}")"
  cat \
    | \
    # 1st argument + '-' + unique number (avoid same argument has same name)
    perl -nle 'print $_."-".(($h{$_}++)+1)' \
    | while read -r _arg
    do
      cat <<<"$_full_fmt" \
        | sed "s/\[:ARG:\]/$_arg/g" \
        | sed "s/\[:PID:\]/$$/g"
    done
}

## --------------------------------
# Normalize directory by making following conversion.
#  * Tilde expansion.
#  * Remove the slash '/' at the end of the dirname.
# Usage:
#        xpns_normalize_directory <direname>
# Return:
#        Normalized <dirname>
## --------------------------------
xpns_normalize_directory() {
  local _dir="$1"
  # Remove end of slash '/'
  _dir="${_dir%/}"
  # tilde expansion
  _dir="${_dir/#~/$HOME}"
  echo "$_dir"
}

## --------------------------------
# Ensure existence of given directory
# Usage:
#        xpns_is_valid_directory <direname>
# Return:
#        Absolute path of the <dirname>
## --------------------------------
xpns_is_valid_directory() {
  local _dir="$1"
  local _checkfile="${XP_THIS_FILE_NAME}.$$"

  # Check directory.
  if [ ! -d "${_dir}" ]; then
    # Create directory
    if mkdir "${_dir}"; then
      xpns_msg "Info" "${_dir} is created."
    else
      xpns_msg "Error" "Failed to create ${_dir}"
      exit $XP_ELOGDIR
    fi
  fi

  # Try to create file.
  #   Not only checking directory permission,
  #   but also i-node and other misc situations.
  if ! touch "${_dir}/$_checkfile"; then
    xpns_msg "Error" "${_dir} is not writable."
    rm -f "${_dir}/$_checkfile"
    exit $XP_ELOGWRITE
  fi
  rm -f "${_dir}/$_checkfile"
}

# Convert array to string which is can be used as command line argument.
# Usage:
#       xpns_arr2args <array object>
# Example:
#       array=(aaa bbb "ccc ddd" eee "f'f")
#       xpns_arr2args "${array[@]}"
#       @returns "'aaa' 'bbb' 'ccc ddd' 'eee' 'f\'f'"
# Result:
xpns_arr2args() {
  local _arg=""
  # If there is no argument, usage will be shown.
  if [ $# -lt 1 ]; then
    return 0
  fi
  for i in "$@" ;do
    _arg="$i"
    # Use 'cat <<<"input"' command instead of 'echo',
    # because such the command recognizes option like '-e'.
    cat <<<"$_arg" \
      | \
      # Escaping single quotations.
      sed "s/'/'\"'\"'/g" \
      | \
      # Surround argument with single quotations.
      sed "s/^/'/;s/$/' /" \
      | \
      # Remove new lines
      tr -d '\n'
  done
}

# Extract first field to generate window name.
# ex, $2     =  'aaa bbb ccc'
#   return   =  aaa-12345(PID)
xpns_generate_window_name() {
  local _unprintable_str="${1-}"; shift
  cat <<<"${1:-$_unprintable_str}" \
    | \
      # Leave first 200 characters to prevent
      # the name exceed the maximum length of tmux window name (2000 byte).
      grep -oE '^.{1,200}' \
    | \
      perl -anle 'printf "%s", "$F[0]-'$$'"'
}

# Convert string to another string which can be handled as tmux window name.
xpns_value2key() {
  perl -nle 'printf unpack("H*", $_);'
}

# Restore string encoded by xpns_value2key function.
xpns_key2value() {
  perl -nle 'printf pack("H*", $_);'
}

#
# Split a new window into multiple panes.
# Usage:
#        xpns_split_window <window name> <num of pane>
#
xpns_split_window() {
  local _window_name="$1" ; shift
  local _args_num="$1"
  for i in $(seq 0 "${_args_num}")
  do
    $TMUX_XPANES_EXEC split-window -t "${_window_name}" -h -d
    $TMUX_XPANES_EXEC select-layout even-horizontal
    # Restraining that size of pane's width becomes
    # less than the minimum size which is defined by tmux.
    if [[ "${i}" -ge 2 ]]; then
      $TMUX_XPANES_EXEC select-layout -t "${_window_name}" tiled
    fi
  done
}

# Enable logging feature to the all the panes in the target window.
xpns_enable_logging() {
  local _window_name="$1" ; shift
  local _index_offset="$1" ; shift
  local _log_dir="$1" ; shift
  local _log_format="$1" ; shift
  local _unprintable_str="$1" ; shift
  local _args=("$@")
  local _args_num=$(($# - 1))
  # Generate log files from arguments.
  local _logfiles=($(
  for i in $(seq 0 "$_args_num")
  do
    # Replace empty string.
    printf "%s\n" "${_args[i]:-$_unprintable_str}"
  done | xpns_log_filenames "$_log_format"
  ))
  for i in $(seq 0 "$_args_num")
  do
    # Start logging
    $TMUX_XPANES_EXEC \
      pipe-pane -t "${_window_name}.$(( i + _index_offset ))" \
      "cat >> '${_log_dir}/${_logfiles[i]}'" # Tilde expansion does not work here.
  done
}

# Send command to the all the panes in the target window.
xpns_send_commands() {
  local _window_name="$1" ; shift
  local _index_offset="$1" ; shift
  local _repstr="$1" ; shift
  local _cmd="$1" ; shift
  local _index=0
  for arg in "$@"
  do
    $TMUX_XPANES_EXEC send-keys -t "$_window_name.$(( _index + _index_offset ))" "${_cmd//$_repstr/$arg}" C-m
    _index=$(( _index + 1 ))
  done
}

# Separate window vertically, when the number of panes is 1 or 2.
xpns_arrange_pane_location() {
  local _window_name="$1" ; shift
  local _args_num="$1"

  ## ----------------
  # Default behavior
  ## ----------------
  if [[ "${_args_num}" -eq 1 ]]; then
    $TMUX_XPANES_EXEC select-layout -t "${_window_name}" even-horizontal
  elif [[ "${_args_num}" -gt 1 ]]; then
    $TMUX_XPANES_EXEC select-layout -t "${_window_name}" tiled
  fi
  ## ----------------
  # Update layout
  ## ----------------
  if [[ "$XP_LAYOUT" != "$XP_DEFAULT_LAYOUT" ]]; then
    $TMUX_XPANES_EXEC select-layout -t "${_window_name}" "$XP_LAYOUT"
  fi
}

#
# Split a new window which was created by tmux into multiple panes.
# Usage:
#    xpns_prepare_window <window name> <offset of index> <number of pane>
#
xpns_prepare_window() {
  local _window_name="$1" ; shift
  local _pane_base_index="$1"; shift
  local _pane_num="$1"; shift
  local _attach_flg="$1"

  # Create new window.
  if [[ "${_attach_flg}" -eq 1 ]]; then
    $TMUX_XPANES_EXEC new-window -n "$_window_name"
  else
    # Keep background
    $TMUX_XPANES_EXEC new-window -n "$_window_name" -d
  fi

  # specify a pane which has the youngest number of index.
  $TMUX_XPANES_EXEC select-pane -t "${_window_name}.${_pane_base_index}"

  # split window into multiple panes
  xpns_split_window "$_window_name" "$_pane_num"

  ### If the first pane is still remaining,
  ### panes cannot be organized well.
  # Delete the first pane
  $TMUX_XPANES_EXEC kill-pane -t "${_window_name}.${_pane_base_index}"

  # Select second pane
  $TMUX_XPANES_EXEC select-pane -t "${_window_name}.${_pane_base_index}"
}

# Check whether given command is in the PATH or not.
xpns_check_env() {
  local _cmds="$1"
  while read -r cmd ; do
    if ! type "$cmd" > /dev/null 2>&1; then
      xpns_msg "Error" "$cmd is required to work."
      exit $XP_ENOCMD
    fi
  done < <(echo "$_cmds" | tr ' ' '\n')

  if ! mkdir -p "$XP_CACHE_HOME";then
    xpns_msg "Warning" "failed to create cache directory '${XP_CACHE_HOME}'."
  fi

  XP_CURRENT_TMUX_VERSION="${XP_CURRENT_TMUX_VERSION:-$(xpns_get_tmux_version)}"
  if ( xpns_tmux_is_greater_equals \
    "${XP_SUPPORT_TMUX_VERSION_LOWER}" \
    "${XP_CURRENT_TMUX_VERSION}" ) ;then
    : "Supported tmux version"
  else
    xpns_msg "Warning" \
"'$XP_THIS_FILE_NAME' may not work correctly!
Current tmux version $XP_CURRENT_TMUX_VERSION is out of support.
Version $XP_SUPPORT_TMUX_VERSION_LOWER and over is officially supported."
  fi

  return 0
}

xpns_pipe_filter() {
  local _number="${1-}"
  if [ -z "${_number-}" ]; then
    cat
  else
    xargs -n "${_number}"
  fi
}

xpns_set_args_per_pane() {
  local _pane_num="$1"; shift
  local _filtered_args=()
  while read -r _line; do
    _filtered_args+=("$_line")
  done < <(xargs -n "${_pane_num}" <<<"$(xpns_arr2args "${XP_ARGS[@]}")")
  XP_ARGS=("${_filtered_args[@]}")
}

# Execute from outside of tmux session
xpns_pre_execution() {
  local _opts4args=""
  local _args4args=""
  # Create new session.
  $TMUX_XPANES_EXEC -S "$XP_SOCKET_PATH" new-session -s "$XP_SESSION_NAME" -n "$XP_TMP_WIN_NAME" -d
  local _def_allow_rename=
  _def_allow_rename="$(xpns_get_tmux_conf 'allow-rename' "$XP_SOCKET_PATH")"
  xpns_suppress_allow_rename "${_def_allow_rename-}" "$XP_SOCKET_PATH"

  # Append -- flag.
  # Because any arguments may have `-`
  if [ $XP_NO_OPT -eq 1 ]; then
    XP_ARGS=("--" "${XP_ARGS[@]}")
  fi

  # Is there is any options, escape them.
  if [ ! -z "${XP_OPTIONS[*]-}" ]; then
    _opts4args=$(xpns_arr2args "${XP_OPTIONS[@]}")
  fi
  _args4args=$(xpns_arr2args "${XP_ARGS[@]}")

  $TMUX_XPANES_EXEC -S "$XP_SOCKET_PATH" \
    send-keys -t "$XP_SESSION_NAME:$XP_TMP_WIN_NAME" \
    "$XP_ABS_THIS_FILE_NAME $_opts4args $_args4args" C-m

  $TMUX_XPANES_EXEC -S "$XP_SOCKET_PATH" \
    send-keys -t "$XP_SESSION_NAME:$XP_TMP_WIN_NAME" "exit" C-m

  # Avoid attaching (for unit testing).
  if [ $XP_OPT_ATTACH -eq 1 ]; then
    if ! $TMUX_XPANES_EXEC -S "$XP_SOCKET_PATH" attach-session -t "$XP_SESSION_NAME" \
      && [ $XP_IS_PIPE_MODE -eq 1 ]; then
      xpns_msg "Recovery" \
"Execute below command line to re-attach the new session.

$TMUX_XPANES_EXEC -S $XP_SOCKET_PATH attach-session -t $XP_SESSION_NAME

"
      # It might be failed. Before applying changes, first window might be closed.
      xpns_restore_allow_rename "${_def_allow_rename-}" "$XP_SOCKET_PATH"
      exit $XP_ETTY
    fi
  fi
  # It might be failed. Before applying changes, first window might be closed.
  xpns_restore_allow_rename "${_def_allow_rename-}" "$XP_SOCKET_PATH"
}

# Execute from inside of tmux session
xpns_execution() {

  if [ $XP_IS_PIPE_MODE -eq 0 ] && [ -n "${XP_MAX_PANE_ARGS-}" ];then
    xpns_set_args_per_pane "${XP_MAX_PANE_ARGS}"
  fi

  local _pane_base_index=
  _pane_base_index=$(xpns_get_tmux_conf 'pane-base-index')
  local _window_name=
  _window_name=$(
    xpns_generate_window_name \
      "$XP_EMPTY_STR" \
      "${XP_ARGS[0]}" \
      | xpns_value2key)
  local _last_args_idx=
  _last_args_idx=$((${#XP_ARGS[@]} - 1))
  local _def_allow_rename=
  _def_allow_rename="$(xpns_get_tmux_conf 'allow-rename')"

  xpns_suppress_allow_rename "${_def_allow_rename-}"

  xpns_prepare_window \
    "$_window_name" \
    "$_pane_base_index" \
    "$_last_args_idx" \
    "$XP_OPT_ATTACH"

  if [ $XP_OPT_LOG_STORE -eq 1 ]; then
    xpns_enable_logging \
      "$_window_name" \
      "$_pane_base_index" \
      "$XP_LOG_DIR" \
      "$XP_LOG_FORMAT" \
      "$XP_EMPTY_STR" \
      "${XP_ARGS[@]}"
  fi

  # Sending ssh operations for each pane.
  xpns_send_commands \
    "$_window_name" \
    "$_pane_base_index" \
    "$XP_REPSTR" \
    "$XP_CMD_UTILITY" \
    "${XP_ARGS[@]}"

  # This is just the author's preference
  # (It means you can remove next statement as you like.)
  xpns_arrange_pane_location \
    "$_window_name" \
    $_last_args_idx

  # Enable broadcasting
  if [ $XP_OPT_IS_SYNC -eq 1 ]; then
    $TMUX_XPANES_EXEC \
      set-window-option -t "${_window_name}" \
      synchronize-panes on
  fi

  # Restore original window name.
  $TMUX_XPANES_EXEC \
    rename-window -t "$_window_name" \
    "$(echo "$_window_name" | xpns_key2value)"

  xpns_restore_allow_rename "${_def_allow_rename-}"

}

## ----------------
# Arrange options for pipe mode
#  * argument -> command utility
#  * stdin -> argument
## ----------------
xpns_switch_pipe_mode() {

  local _pane_num4new_term=""
  if [ ! -z "${XP_ARGS[*]-}" ] && [ ! -z "${XP_CMD_UTILITY-}" ]; then
    xpns_msg "Error" "Both arguments and other options (like '-c', '-e') which updates <utility> are given."
    exit $XP_EINVAL
  fi

  if [ -z "${TMUX-}" ]; then
    xpns_msg "Warning" "'Pipe mode' requires attached session."
    # This condition is used when the following situations.
    #   * Executed outside of tmux session
    #   * Pipe mode.
    #   * -n option.
    #
    # For example:
    #     (outside of tmux session)$ echo {a..g} | ./xpanes -n 2
    # => This will once create the new window like this.
    #     (inside of tmux session)$ ./xpanes '-n' '2' 'a' 'b' 'c' 'd' 'e' 'f' 'g'
    #     => After the window is closed, following panes would be left.
    #     (pane 1)$ echo a b
    #     (pane 2)$ echo c d
    #     (pane 3)$ echo e f
    #     (pane 4)$ echo g
    # In order to create such the query,
    # separate all the argument into minimum tokens
    # with xargs -n 1
    if [ -n "${XP_MAX_PANE_ARGS-}" ]; then
      _pane_num4new_term=1
    fi
  fi

  while read -r line;
  do
    XP_STDIN+=("$line")
  done < <(cat \
             | \
             # Remove empty lines
             perl -anle '$#F >= 0 and print' \
             | \
             xpns_pipe_filter "${_pane_num4new_term:-$XP_MAX_PANE_ARGS}"
           )


  # Merge them into utility.
  if [ ! -z "${XP_ARGS[*]-}" ]; then
    # Attention: It might be wrong result if IFS is changed.
    XP_CMD_UTILITY="${XP_ARGS[*]}"
  fi

  # If there is empty -I option or user does not assign the <repstr>,
  # Append the space and <repstr> at the end of the <utility>
  # This is same as the xargs command of GNU.
  # i.e,
  #   $ echo 10 | xargs seq
  #     => seq 10
  # Whith is same as
  #   $ echo 10 | xargs -I@ seq @
  #     => seq 10
  if [ -z "$XP_REPSTR" ]; then
    XP_REPSTR="$XP_DEFAULT_REPSTR"
    if [ ! -z "${XP_ARGS[*]-}" ]; then
      XP_CMD_UTILITY="${XP_ARGS[*]-} $XP_REPSTR"
    fi
  fi

  # Deal with stdin as arguments.
  XP_ARGS=("${XP_STDIN[@]-}")
}

xpns_layout_short2long() {
  sed \
    -e 's/^t$/tiled/' \
    -e 's/^eh$/even-horizontal/' \
    -e 's/^ev$/even-vertical/' \
    -e 's/^mh$/main-horizontal/' \
    -e 's/^mv$/main-vertical/' \
    -e ';'
}

xpns_is_valid_layout() {
  local _layout="$1"
  if ! echo "$1" | grep -qE '^(tiled|even-horizontal|even-vertical|main-horizontal|main-vertical)$'; then
    xpns_msg "Error" "Invalid layout '$_layout'."
    exit $XP_ELAYOUT
  fi
}

xpns_load_flag_options() {
  if   [[ "$1" =~ h ]]; then
    xpns_usage
    xpns_usage_verbose
    exit 0
  fi
  if [[ "$1" =~ V ]]; then
    xpns_version
    exit 0
  fi
  if [[ "$1" =~ d ]]; then
    XP_OPT_IS_SYNC=0
  fi
  if [[ "$1" =~ e ]]; then
    XP_REPSTR="{}"
    XP_CMD_UTILITY="{}"
  fi
  return 1
}

xpns_load_arg_options() {
  # Extract flag options only.
  xpns_load_flag_options "$(cat <<<"$1" | perl -nle "/^-$XP_FLAG_OPTIONS+/ and print $&")" > /dev/null
  if [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*I ]]; then
    # Behavior like this.
    # -IAAA       -- XP_REPSTR="AAA"
    # -I AAA BBB  -- XP_REPSTR="AAA", XP_ARGS=("BBB")
    # -I"AAA BBB" -- XP_REPSTR="AAA BBB"
    # -IAAA BBB   -- XP_REPSTR="AAA", XP_ARGS=("BBB")
    # -I -d ...   -- XP_REPSTR=""
    if [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*I.+ ]]; then
      XP_REPSTR="$(cat <<<"$1" | perl -ple "s/^-${XP_FLAG_OPTIONS}*?I//")"
      return 0
    elif ! [[ "$2" =~ ^-.* ]]; then
      XP_REPSTR="$2"
      return 0
    else
      xpns_msg "Error" "invalid argument '$2' for -I option"
      exit $XP_EINVAL
    fi
  elif [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*l ]]; then
    if [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*l.+ ]]; then
      XP_LAYOUT="$(cat <<<"$1" | perl -ple "s/^-${XP_FLAG_OPTIONS}*?l//" | xpns_layout_short2long)"
      xpns_is_valid_layout "$XP_LAYOUT"
      return 0
    elif ! [[ "$2" =~ ^-.* ]]; then
      XP_LAYOUT="$(cat <<<"$2" |  xpns_layout_short2long )"
      xpns_is_valid_layout "$XP_LAYOUT"
      return 0
    else
      xpns_msg "Error" "invalid argument '$2' for -l option"
      exit $XP_EINVAL
    fi
  elif [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*c ]]; then
    if [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*c.+ ]]; then
      XP_CMD_UTILITY="$(cat <<<"$1" | perl -ple "s/^-${XP_FLAG_OPTIONS}*?c//")"
      XP_OPT_CMD_UTILITY=1
      return 0
    elif ! [[ "$2" =~ ^-.* ]]; then
      XP_CMD_UTILITY="$2"
      XP_OPT_CMD_UTILITY=1
      return 0
    else
      xpns_msg "Error" "invalid argument '$2' for -c option"
      exit $XP_EINVAL
    fi
  elif [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*n ]]; then
    if [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*n.+ ]]; then
      XP_MAX_PANE_ARGS="$(cat <<<"$1" | perl -ple "s/^-${XP_FLAG_OPTIONS}*?n//")"
      return 0
    elif ! [[ "$2" =~ ^-.* ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
      XP_MAX_PANE_ARGS="$2"
      return 0
    else
      xpns_msg "Error" "invalid argument '$2' for -n option"
      exit $XP_EINVAL
    fi
  elif [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*S ]]; then
    if [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*S.+ ]]; then
      XP_SOCKET_PATH="$(cat <<<"$1" | perl -ple "s/^-${XP_FLAG_OPTIONS}*?S//")"
      return 0
    elif ! [[ "$2" =~ ^-.* ]]; then
      XP_SOCKET_PATH="$2"
      return 0
    else
      xpns_msg "Error" "invalid argument '$2' for -S option"
      exit $XP_EINVAL
    fi
  fi
  return 0
}

xpns_load_long_options() {
  if   [[ "$1" =~ ^--help$ ]]; then
    xpns_usage
    xpns_usage_verbose
    exit 0
  elif [[ "$1" =~ ^--version$ ]]; then
    xpns_version
    exit 0
  elif [[ "$1" =~ ^--desync$ ]]; then
    XP_OPT_IS_SYNC=0
    return 1
  elif [[ "$1" =~ ^--log-format=.*$ ]]; then
    XP_OPT_LOG_STORE=1
    XP_LOG_FORMAT="${1#--log-format=}"
    return 1
  elif [[ "$1" =~ ^--log ]]; then
    XP_OPT_LOG_STORE=1
    if [[ "$1" =~ ^--log=.*$  ]]; then
      XP_LOG_DIR="${1#--log=}"
    fi
    return 1
  elif [[ "$1" =~ ^--ssh$ ]]; then
    XP_CMD_UTILITY="$XP_SSH_CMD_UTILITY"
    return 1
    # For unit testing
  elif [[ "$1" =~ ^--dry-run$ ]]; then
    XP_OPT_DRY_RUN=1
    return 1
  elif [[ "$1" =~ ^--stay$ ]]; then
    XP_OPT_ATTACH=0
    return 1

  ## ----------------
  # Other options
  ## ----------------
  else
    xpns_msg "Error" "invalid option -- '${1#--}'"
    xpns_usage
    echo "Try '$XP_THIS_FILE_NAME --help' for more information." >&2
    exit $XP_EINVAL
  fi
}

xpns_parse_options() {
  while (( $# > 0 ))
  do
    case "$1" in
      --)
      if [ $XP_NO_OPT -eq 1 ]; then
        XP_ARGS+=("$1")
        shift
      else
        # Disable any more options
        XP_NO_OPT=1
        shift
      fi
      ;;
      ## ----------------
      # Long options
      ## ----------------
      --*)
      if [ $XP_NO_OPT -eq 1 ]; then
        XP_ARGS+=("$1")
        shift
      else
        local _shift_count="0"
        xpns_load_long_options "$@"
        _shift_count="$?"
        [ "$_shift_count" = "1" ] && XP_OPTIONS+=("$1") && shift
      fi
      ;;
      ## ----------------
      # Short options
      ## ----------------
      -*)
      if [ $XP_NO_OPT -eq 1 ]; then
        XP_ARGS+=("$1")
        shift
      else
        local _shift_count="0"
        if [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*${XP_ARG_OPTIONS}. ]];then
          xpns_load_arg_options "$@"
          XP_OPTIONS+=("$1") && shift
        elif [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*${XP_ARG_OPTIONS}$ ]] && [ -n "${2-}" ];then
          xpns_load_arg_options "$@"
          _shift_count="$?"
          XP_OPTIONS+=("$1" "$2") && shift && shift
        elif [[ "$1" =~ ^-${XP_FLAG_OPTIONS}+$  ]];then
          xpns_load_flag_options "$1"
          XP_OPTIONS+=("$1") && shift
        ## ----------------
        # Other options
        ## ----------------
        else
          xpns_msg "Error" "Invalid option -- '${1#-}'"
          xpns_usage
          echo "Try '$XP_THIS_FILE_NAME --help' for more information." >&2
          exit $XP_EINVAL
        fi
      fi
      ;;
      ## ----------------
      # Other arguments
      ## ----------------
      *)
      XP_ARGS+=("$1")
      XP_NO_OPT=1
      shift
      ;;
    esac
  done

  # If there is any standard input from pipe,
  # 1 line handled as 1 argument.
  if [ ! -t 0 ]; then
    XP_IS_PIPE_MODE=1
    xpns_switch_pipe_mode
  fi

  # When no argument arr given, exit.
  if [ -z "${XP_ARGS[*]-}" ]; then
    xpns_msg "Error" "No arguments are given."
    xpns_usage
    echo "Try '$XP_THIS_FILE_NAME --help' for more information." >&2
    exit $XP_EINVAL
  fi

  # Set default value in case of empty.
  XP_CMD_UTILITY="${XP_CMD_UTILITY:-$XP_DEFAULT_CMD_UTILITY}"
  XP_REPSTR="${XP_REPSTR:-$XP_DEFAULT_REPSTR}"

  # To set utility on pre_execution, set -c option manually.
  if [ $XP_OPT_CMD_UTILITY -eq 0 ];then
    XP_OPTIONS+=("-c" "$XP_CMD_UTILITY")
  fi
}

## --------------------------------
# Main function
## --------------------------------
xpns_main() {
  xpns_parse_options "${1+"$@"}"
  xpns_check_env "$XP_DEPENDENCIES"
  ## --------------------------------
  # Parameter validation
  ## --------------------------------
  # When do dry-run flag is enabled, skip running (this is used to execute unit test of itself).
  if [ $XP_OPT_DRY_RUN -eq 1 ]; then
    return 0
  fi
  # Validate log directory.
  if [ $XP_OPT_LOG_STORE -eq 1 ]; then
    XP_LOG_DIR=$(xpns_normalize_directory "$XP_LOG_DIR")
    xpns_is_valid_directory "$XP_LOG_DIR" && \
    XP_LOG_DIR=$(cd "$XP_LOG_DIR" && pwd)
  fi
  ## --------------------------------
  # If current shell is outside of tmux session.
  ## --------------------------------
  if [ -z "${TMUX-}" ]; then
    xpns_pre_execution
  ## --------------------------------
  # If current shell is already inside of tmux session.
  ## --------------------------------
  else
    xpns_execution
  fi
  exit 0
}

## --------------------------------
# Entry Point
## --------------------------------
xpns_main "${1+"$@"}"
